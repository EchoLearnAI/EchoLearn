package main

import (
	"encoding/json"
	"log"
	"net/http"

	"github.com/gin-gonic/gin"
	swaggerFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"

	_ "echotech-backend/docs" // docs is generated by Swag CLI
)

// @title EchoTech API
// @version 1.0
// @description This is the API for the EchoTech learning platform.
// @termsOfService http://swagger.io/terms/

// @contact.name API Support
// @contact.url http://www.swagger.io/support
// @contact.email support@swagger.io

// @license.name Apache 2.0
// @license.url http://www.apache.org/licenses/LICENSE-2.0.html

// @host localhost:8080
// @BasePath /api/v1
func main() {
	// Load .env file if it exists (for local development)
	// You would typically use a library like godotenv for this
	// For simplicity, we'll assume env vars are set externally or defaults are fine for now

	ConnectDatabase() // Initialize DB connection
	SeedDatabase(DB)  // Seed the database with initial data

	r := gin.Default()

	// Enable CORS
	r.Use(CORSMiddleware())

	// Public quiz routes (no auth needed)
	quizRoutes := r.Group("/api/v1")
	{
		quizRoutes.GET("/ping", Ping)
		quizRoutes.GET("/difficulties", GetDifficulties)
		quizRoutes.GET("/categories", GetCategories)
		quizRoutes.GET("/topics", GetTopics)
		quizRoutes.GET("/questions/:difficulty/:topic", GetQuestionsByDifficultyAndTopic)
		quizRoutes.POST("/submit", SubmitAnswer) // This is quiz submission, not score persistence
	}

	// Auth routes
	authRoutes := r.Group("/api/v1/auth")
	{
		authRoutes.POST("/register", Register)
		authRoutes.POST("/login", Login)
	}

	// Authenticated routes for scores
	protectedRoutes := r.Group("/api/v1")
	protectedRoutes.Use(AuthMiddleware(jwtKey)) // Apply JWT middleware, passing the key
	{
		protectedRoutes.POST("/scores", SubmitScore)           // To save a new score after a quiz
		protectedRoutes.GET("/users/me/scores", GetUserScores) // To get scores for the logged-in user
	}

	// Swagger
	r.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))
	// Add security definitions for Swagger UI
	// @securityDefinitions.apikey BearerAuth
	// @in header
	// @name Authorization
	// @description Type "Bearer" followed by a space and JWT token.

	r.Run(":8080") // listen and serve on 0.0.0.0:8080
}

// Ping godoc
// @Summary Ping the server
// @Description get "pong" response to check if server is alive
// @Tags health
// @Accept  json
// @Produce  json
// @Success 200 {object} map[string]string
// @Router /ping [get]
func Ping(c *gin.Context) {
	c.JSON(http.StatusOK, gin.H{
		"message": "pong",
	})
}

// CORSMiddleware creates a new middleware handler for CORS
func CORSMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		c.Writer.Header().Set("Access-Control-Allow-Origin", "*") // Allow all origins
		c.Writer.Header().Set("Access-Control-Allow-Credentials", "true")
		c.Writer.Header().Set("Access-Control-Allow-Headers", "Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, accept, origin, Cache-Control, X-Requested-With")
		c.Writer.Header().Set("Access-Control-Allow-Methods", "POST, OPTIONS, GET, PUT, DELETE")

		if c.Request.Method == "OPTIONS" {
			c.AbortWithStatus(204)
			return
		}

		c.Next()
	}
}

// GetDifficulties godoc
// @Summary Get available difficulties
// @Description Get a list of available difficulties
// @Tags quiz
// @Accept  json
// @Produce  json
// @Success 200 {object} map[string][]string
// @Router /difficulties [get]
func GetDifficulties(c *gin.Context) {
	difficulties := []string{"easy", "medium", "hard"}
	c.JSON(http.StatusOK, gin.H{"difficulties": difficulties})
}

// GetCategories godoc
// @Summary Get all available categories
// @Description Get a list of all quiz categories
// @Tags quiz
// @Accept  json
// @Produce  json
// @Success 200 {object} map[string][]CategoryDTO "List of categories"
// @Failure 500 {object} map[string]string "Internal server error"
// @Router /categories [get]
func GetCategories(c *gin.Context) {
	var categories []Category
	if err := DB.Order("name asc").Find(&categories).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve categories: " + err.Error()})
		return
	}
	c.JSON(http.StatusOK, gin.H{"categories": categories})
}

// GetTopics godoc
// @Summary Get available topics
// @Description Get a list of available topics, optionally filtered by category slug.
// @Tags quiz
// @Accept  json
// @Produce  json
// @Param category_slug query string false "Slug of the category to filter topics by"
// @Success 200 {object} map[string][]TopicDTO "List of topics"
// @Failure 404 {object} map[string]string "Category not found if category_slug is provided and invalid"
// @Failure 500 {object} map[string]string "Internal server error"
// @Router /topics [get]
func GetTopics(c *gin.Context) {
	categorySlug := c.Query("category_slug")
	var topics []Topic
	query := DB.Preload("Category").Order("name asc")

	if categorySlug != "" {
		var category Category
		if err := DB.First(&category, "slug = ?", categorySlug).Error; err != nil {
			c.JSON(http.StatusNotFound, gin.H{"error": "Category not found: " + categorySlug})
			return
		}
		query = query.Where("category_id = ?", category.ID)
	}

	if err := query.Find(&topics).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve topics: " + err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"topics": topics})
}

// GetQuestionsByDifficultyAndTopic godoc
// @Summary Get questions by difficulty and topic
// @Description Get a list of questions for a specific difficulty and topic
// @Tags quiz
// @Accept  json
// @Produce  json
// @Param difficulty path string true "Difficulty level (easy, medium, hard)"
// @Param topic path string true "Topic name"
// @Success 200 {object} map[string][]Question
// @Router /questions/{difficulty}/{topic} [get]
func GetQuestionsByDifficultyAndTopic(c *gin.Context) {
	difficulty := c.Param("difficulty")
	topicSlug := c.Param("topic") // Renamed for clarity, was 'topic'
	log.Printf("GetQuestions: Received request for difficulty '%s', topicSlug '%s'", difficulty, topicSlug)

	// 1. Find the topic by slug to get its ID
	var topic Topic
	if err := DB.First(&topic, "slug = ?", topicSlug).Error; err != nil {
		log.Printf("GetQuestions: Topic with slug '%s' not found. Error: %v", topicSlug, err)
		c.JSON(http.StatusNotFound, gin.H{"error": "Topic not found: " + topicSlug})
		return
	}
	log.Printf("GetQuestions: Found topic: ID=%d, Name='%s', Slug='%s'", topic.ID, topic.Name, topic.Slug)

	// 2. Query questions from the database
	var dbQuestions []Question // These are GORM models
	if err := DB.Where("topic_id = ? AND difficulty = ?", topic.ID, difficulty).Find(&dbQuestions).Error; err != nil {
		log.Printf("GetQuestions: Error retrieving questions for TopicID %d, Difficulty '%s'. Error: %v", topic.ID, difficulty, err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve questions: " + err.Error()})
		return
	}
	log.Printf("GetQuestions: Found %d questions in DB for TopicID %d, Difficulty '%s'", len(dbQuestions), topic.ID, difficulty)

	// 3. Prepare questions for response, unmarshalling options
	responseQuestions := []gin.H{}
	for _, q := range dbQuestions {
		var options []Option
		if err := json.Unmarshal(q.Options, &options); err != nil {
			// Log error, maybe skip this question or return an error for it
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to parse options for question ID " + q.OriginalID})
			return
		}
		responseQuestions = append(responseQuestions, gin.H{
			"id":         q.OriginalID, // Use OriginalID for consistency with old frontend if needed, or q.ID for DB ID
			"topic":      topic.Name,   // Or topic.Slug if preferred by frontend
			"difficulty": q.Difficulty,
			"text":       q.Text,
			"options":    options,
		})
	}
	log.Printf("GetQuestions: Sending %d questions in response for topic '%s', difficulty '%s'", len(responseQuestions), topic.Name, difficulty)

	c.JSON(http.StatusOK, gin.H{"questions": responseQuestions})
}

// SubmitAnswerBody defines the structure for submitting an answer
type SubmitAnswerBody struct {
	QuestionID string `json:"questionId"`
	AnswerID   string `json:"answerId"`
}

// SubmitAnswer godoc
// @Summary Submit an answer to a question
// @Description Submit an answer and get feedback
// @Tags quiz
// @Accept  json
// @Produce  json
// @Param submission body SubmitAnswerBody true "Submission Payload"
// @Success 200 {object} map[string]interface{}
// @Router /submit [post]
func SubmitAnswer(c *gin.Context) {
	var body SubmitAnswerBody
	if err := c.ShouldBindJSON(&body); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	var dbQuestion Question // This is the GORM model
	// 1. Fetch question from DB using OriginalID
	if err := DB.First(&dbQuestion, "original_id = ?", body.QuestionID).Error; err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Question not found"})
		return
	}

	// 2. Unmarshal options from JSONB
	var questionOptions []Option
	if err := json.Unmarshal(dbQuestion.Options, &questionOptions); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to parse question options"})
		return
	}

	var userSelectedOption Option
	optionFound := false
	for _, opt := range questionOptions {
		if opt.ID == body.AnswerID {
			userSelectedOption = opt
			optionFound = true
			break
		}
	}

	if !optionFound {
		c.JSON(http.StatusNotFound, gin.H{"error": "Selected option not found for the question"})
		return
	}

	// Prepare all options with their details for the response
	optionsWithDetails := []Option{}
	for _, opt := range questionOptions {
		optionsWithDetails = append(optionsWithDetails, Option{
			ID:          opt.ID,
			Text:        opt.Text,
			IsCorrect:   opt.IsCorrect,
			Explanation: opt.Explanation,
		})
	}

	c.JSON(http.StatusOK, gin.H{
		"questionId":       dbQuestion.OriginalID, // Or dbQuestion.ID if you want to return the numeric DB ID
		"selectedOptionId": userSelectedOption.ID,
		"isCorrect":        userSelectedOption.IsCorrect,
		"options":          optionsWithDetails,
	})
}
