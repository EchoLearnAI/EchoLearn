package main

import (
	"net/http"

	"github.com/gin-gonic/gin"
	swaggerFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"

	_ "echotech-backend/docs" // docs is generated by Swag CLI
)

// @title EchoTech API
// @version 1.0
// @description This is the API for the EchoTech learning platform.
// @termsOfService http://swagger.io/terms/

// @contact.name API Support
// @contact.url http://www.swagger.io/support
// @contact.email support@swagger.io

// @license.name Apache 2.0
// @license.url http://www.apache.org/licenses/LICENSE-2.0.html

// @host localhost:8080
// @BasePath /api/v1
func main() {
	// Load .env file if it exists (for local development)
	// You would typically use a library like godotenv for this
	// For simplicity, we'll assume env vars are set externally or defaults are fine for now

	ConnectDatabase() // Initialize DB connection

	r := gin.Default()

	// Enable CORS
	r.Use(CORSMiddleware())

	// Public quiz routes (no auth needed)
	quizRoutes := r.Group("/api/v1")
	{
		quizRoutes.GET("/ping", Ping)
		quizRoutes.GET("/difficulties", GetDifficulties)
		quizRoutes.GET("/topics", GetTopics)
		quizRoutes.GET("/questions/:difficulty/:topic", GetQuestionsByDifficultyAndTopic)
		quizRoutes.POST("/submit", SubmitAnswer) // This is quiz submission, not score persistence
	}

	// Auth routes
	authRoutes := r.Group("/api/v1/auth")
	{
		authRoutes.POST("/register", Register)
		authRoutes.POST("/login", Login)
	}

	// Authenticated routes for scores
	protectedRoutes := r.Group("/api/v1")
	protectedRoutes.Use(AuthMiddleware(jwtKey)) // Apply JWT middleware, passing the key
	{
		protectedRoutes.POST("/scores", SubmitScore)           // To save a new score after a quiz
		protectedRoutes.GET("/users/me/scores", GetUserScores) // To get scores for the logged-in user
	}

	// Swagger
	r.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))
	// Add security definitions for Swagger UI
	// @securityDefinitions.apikey BearerAuth
	// @in header
	// @name Authorization
	// @description Type "Bearer" followed by a space and JWT token.

	r.Run(":8080") // listen and serve on 0.0.0.0:8080
}

// Ping godoc
// @Summary Ping the server
// @Description get "pong" response to check if server is alive
// @Tags health
// @Accept  json
// @Produce  json
// @Success 200 {object} map[string]string
// @Router /ping [get]
func Ping(c *gin.Context) {
	c.JSON(http.StatusOK, gin.H{
		"message": "pong",
	})
}

// CORSMiddleware creates a new middleware handler for CORS
func CORSMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		c.Writer.Header().Set("Access-Control-Allow-Origin", "*") // Allow all origins
		c.Writer.Header().Set("Access-Control-Allow-Credentials", "true")
		c.Writer.Header().Set("Access-Control-Allow-Headers", "Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, accept, origin, Cache-Control, X-Requested-With")
		c.Writer.Header().Set("Access-Control-Allow-Methods", "POST, OPTIONS, GET, PUT, DELETE")

		if c.Request.Method == "OPTIONS" {
			c.AbortWithStatus(204)
			return
		}

		c.Next()
	}
}

// GetDifficulties godoc
// @Summary Get available difficulties
// @Description Get a list of available difficulties
// @Tags quiz
// @Accept  json
// @Produce  json
// @Success 200 {object} map[string][]string
// @Router /difficulties [get]
func GetDifficulties(c *gin.Context) {
	difficulties := []string{"easy", "medium", "hard"}
	c.JSON(http.StatusOK, gin.H{"difficulties": difficulties})
}

// GetTopics godoc
// @Summary Get available topics
// @Description Get a list of available topics
// @Tags quiz
// @Accept  json
// @Produce  json
// @Success 200 {object} map[string][]string
// @Router /topics [get]
func GetTopics(c *gin.Context) {
	topics := []string{
		"Network", "Cybersecurity", "VMs", "Container", "Architecture",
		"Databases", "Git", "Cache and CDN", "Monitoring", "Admin and Ops",
		"Kubernetes", "Linux", "Pipelines and CI/CD", "APIs", "Terraform",
		"Ansible", "Azure", "AWS", "GCP",
	}
	c.JSON(http.StatusOK, gin.H{"topics": topics})
}

// GetQuestionsByDifficultyAndTopic godoc
// @Summary Get questions by difficulty and topic
// @Description Get a list of questions for a specific difficulty and topic
// @Tags quiz
// @Accept  json
// @Produce  json
// @Param difficulty path string true "Difficulty level (easy, medium, hard)"
// @Param topic path string true "Topic name"
// @Success 200 {object} map[string][]Question
// @Router /questions/{difficulty}/{topic} [get]
func GetQuestionsByDifficultyAndTopic(c *gin.Context) {
	difficulty := c.Param("difficulty")
	topic := c.Param("topic")

	filteredQuestions := []Question{}
	for _, q := range questions { // questions would be from data.go
		if q.Difficulty == difficulty && q.Topic == topic {
			filteredQuestions = append(filteredQuestions, q)
		}
	}
	c.JSON(http.StatusOK, gin.H{"questions": filteredQuestions})
}

// SubmitAnswerBody defines the structure for submitting an answer
type SubmitAnswerBody struct {
	QuestionID string `json:"questionId"`
	AnswerID   string `json:"answerId"`
}

// SubmitAnswer godoc
// @Summary Submit an answer to a question
// @Description Submit an answer and get feedback
// @Tags quiz
// @Accept  json
// @Produce  json
// @Param submission body SubmitAnswerBody true "Submission Payload"
// @Success 200 {object} map[string]interface{}
// @Router /submit [post]
func SubmitAnswer(c *gin.Context) {
	var body SubmitAnswerBody
	if err := c.ShouldBindJSON(&body); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	var selectedQuestion Question
	var userSelectedOption Option // To store the option chosen by the user
	questionFound := false
	optionFound := false

	for _, q := range questions {
		if q.ID == body.QuestionID {
			selectedQuestion = q
			questionFound = true
			for _, opt := range q.Options {
				if opt.ID == body.AnswerID {
					userSelectedOption = opt
					optionFound = true
					break
				}
			}
			break
		}
	}

	if !questionFound {
		c.JSON(http.StatusNotFound, gin.H{"error": "Question not found"})
		return
	}

	if !optionFound {
		c.JSON(http.StatusNotFound, gin.H{"error": "Selected option not found for the question"})
		return
	}

	// Prepare all options with their details for the response
	optionsWithDetails := []Option{}
	for _, opt := range selectedQuestion.Options {
		optionsWithDetails = append(optionsWithDetails, Option{
			ID:          opt.ID,
			Text:        opt.Text,
			IsCorrect:   opt.IsCorrect,   // Expose IsCorrect for all options
			Explanation: opt.Explanation, // Expose Explanation for all options
		})
	}

	c.JSON(http.StatusOK, gin.H{
		"questionId":       selectedQuestion.ID,
		"selectedOptionId": userSelectedOption.ID,
		"isCorrect":        userSelectedOption.IsCorrect, // User's choice correctness
		"options":          optionsWithDetails,           // All options with full details
	})
}
